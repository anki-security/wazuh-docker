{
  "description": "MikroTik RouterOS Syslog Parsing Pipeline - Enhanced with ECS fields",
  "processors": [
    {
      "grok": {
        "field": "message",
        "patterns": [
          "^%{DATA:log.syslog.facility.name},%{DATA:log.syslog.severity.name} %{DATA:event.action}: in:%{DATA:network.interface.in} out:%{DATA:network.interface.out}, ?(connection-state:%{DATA:network.connection.state},|)?(src-mac %{MAC:source.mac},|) proto %{DATA:network.transport}( \\(%{DATA:network.protocol}\\)|), %{IP:source.ip}:?(%{INT:source.port}|)->%{IP:destination.ip}:?(%{INT:destination.port}|), len %{INT:network.bytes}$",
          "^dhcp,%{DATA:log.syslog.severity.name}(,packet|) dhcp%{INT:dhcp.server_id} (received|sending) %{DATA:dhcp.message_type} (with |)id %{INT:dhcp.transaction_id}",
          "^dhcp,%{DATA:log.syslog.severity.name},packet\\s+%{DATA:dhcp.field_name} = %{GREEDYDATA:dhcp.field_value}$",
          "^dns,%{DATA:log.syslog.severity.name} query from %{IP:client.ip}: #%{INT:dns.query_id} %{DATA:dns.query_name} %{DATA:dns.query_type}$",
          "^dns,packet --- (got query from|sending reply to|got answer from|sending udp query to) %{IP:source.ip}:%{INT:source.port}",
          "^dns,packet id:%{BASE16NUM:dns.packet_id}",
          "^dns,packet question: %{DATA:dns.question}",
          "^dns,packet answer:",
          "^dns,packet <%{DATA:dns.answer}>",
          "^ipsec %{DATA:ipsec.message} %{IP:source.ip}\\[%{INT:source.port}\\]<?=>?%{IP:destination.ip}\\[%{INT:destination.port}\\]",
          "^first L2TP UDP packet received from %{IP:source.ip}$",
          "^login failure for user %{USERNAME:user.name} from %{IP:source.ip} via %{DATA:service.name}$",
          "^%{USERNAME:user.name} logged in, %{IP:client.ip} from %{IP:source.ip}$",
          "^dhcp alert on %{DATA:network.name}: discovered unknown dhcp server, mac %{MAC:source.mac}, ip %{IP:source.ip}$",
          "in:%{DATA:network.interface.in} out:%{DATA:network.interface.out}, ?(connection-state:%{DATA:network.connection.state},|)?(src-mac %{MAC:source.mac},|) proto %{DATA:network.transport} \\(%{DATA:network.protocol}\\), %{IP:source.ip}:?(%{INT:source.port}|)->%{IP:destination.ip}:?(%{INT:destination.port}|), len %{INT:network.bytes}$",
          "in:%{DATA:network.interface.in} out:%{DATA:network.interface.out}, ?(connection-state:%{DATA:network.connection.state},|)?(src-mac %{MAC:source.mac},|) proto %{DATA:network.transport}, %{IP:source.ip}:?(%{INT:source.port}|)->%{IP:destination.ip}:?(%{INT:destination.port}|), len %{INT:network.bytes}$",
          "^%{DATA:network.name} (deassigned|assigned) %{IP:client.ip} for %{MAC:client.mac} %{DATA:dhcp.info}$",
          "^%{DATA:user.name} logged out, %{INT:event.duration} %{INT:session.packets.sent} %{INT:session.packets.received} %{INT:session.bytes.sent} %{INT:session.bytes.received} from %{IP:client.ip}$",
          "^user %{DATA:user.name} logged out from %{IP:source.ip} via %{DATA:service.name}$",
          "^user %{DATA:user.name} logged in from %{IP:source.ip} via %{DATA:service.name}$",
          "^%{DATA:network.name} client %{MAC:client.mac} declines IP address %{IP:client.ip}$",
          "^%{DATA:network.name} link up \\(speed %{DATA:network.speed}\\)$",
          "^%{DATA:network.name} link down$",
          "^user %{DATA:user.name} authentication failed$",
          "^%{DATA:network.name} fcs error on link$",
          "^phase1 negotiation failed due to time up %{IP:source.ip}\\[%{INT:source.port}\\]<=>%{IP:destination.ip}\\[%{INT:destination.port}\\] %{DATA:vpn.info}$",
          "^%{DATA:network.name} (learning|forwarding)$",
          "^user %{DATA:user.name} is already active$",
          "^%{GREEDYDATA:message.unparsed}$"
        ],
        "ignore_failure": true
      }
    },
    {
      "lowercase": {
        "field": "network.transport",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "append": {
        "field": "event.category",
        "value": ["authentication"],
        "if": "ctx.message?.contains('logged in') || ctx.message?.contains('logged out') || ctx.message?.contains('login failure')",
        "allow_duplicates": false
      }
    },
    {
      "append": {
        "field": "event.type",
        "value": ["start"],
        "if": "ctx.message?.contains('logged in')",
        "allow_duplicates": false
      }
    },
    {
      "append": {
        "field": "event.type",
        "value": ["end"],
        "if": "ctx.message?.contains('logged out')",
        "allow_duplicates": false
      }
    },
    {
      "set": {
        "field": "event.outcome",
        "value": "success",
        "if": "ctx.message?.contains('logged in')"
      }
    },
    {
      "set": {
        "field": "event.outcome",
        "value": "failure",
        "if": "ctx.message?.contains('login failure') || ctx.message?.contains('authentication failed')"
      }
    },
    {
      "append": {
        "field": "event.category",
        "value": ["network"],
        "if": "ctx.network?.transport != null || ctx.source?.ip != null || ctx.destination?.ip != null",
        "allow_duplicates": false
      }
    },
    {
      "append": {
        "field": "event.type",
        "value": ["connection"],
        "if": "ctx.network?.transport != null && ctx.source?.ip != null && ctx.destination?.ip != null",
        "allow_duplicates": false
      }
    },
    {
      "convert": {
        "field": "source.port",
        "type": "long",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "convert": {
        "field": "destination.port",
        "type": "long",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "convert": {
        "field": "network.bytes",
        "type": "long",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "convert": {
        "field": "event.duration",
        "type": "long",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "geoip": {
        "field": "source.ip",
        "target_field": "source.geo",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "geoip": {
        "field": "destination.ip",
        "target_field": "destination.geo",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "geoip": {
        "database_file": "GeoLite2-ASN.mmdb",
        "field": "source.ip",
        "target_field": "source.as",
        "properties": ["asn", "organization_name"],
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "rename": {
        "field": "source.as.asn",
        "target_field": "source.as.number",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "rename": {
        "field": "source.as.organization_name",
        "target_field": "source.as.organization.name",
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "set": {
        "field": "observer.vendor",
        "value": "MikroTik"
      }
    },
    {
      "set": {
        "field": "observer.product",
        "value": "RouterOS"
      }
    },
    {
      "set": {
        "field": "observer.type",
        "value": "firewall"
      }
    },
    {
      "set": {
        "field": "ecs.version",
        "value": "8.12.0"
      }
    },
    {
      "remove": {
        "field": ["message.unparsed"],
        "ignore_missing": true,
        "ignore_failure": true
      }
    },
    {
      "pipeline": {
        "name": "logs-routeros.syslog@custom",
        "ignore_failure": true
      }
    }
  ],
  "on_failure": [
    {
      "set": {
        "field": "error.message",
        "value": "{{ _ingest.on_failure_message }}"
      }
    },
    {
      "set": {
        "field": "event.kind",
        "value": "pipeline_error"
      }
    }
  ]
}
